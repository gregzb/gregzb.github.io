<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Technical on Greg Zborovsky</title>
    <link>/tags/technical/</link>
    <description>Recent content in Technical on Greg Zborovsky</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Mon, 18 Oct 2021 12:00:00 -0400</lastBuildDate><atom:link href="/tags/technical/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linking With Linked Lists</title>
      <link>/posts/linking-with-linked-lists/</link>
      <pubDate>Mon, 18 Oct 2021 12:00:00 -0400</pubDate>
      
      <guid>/posts/linking-with-linked-lists/</guid>
      <description>Note: This is a post originally written and posted to my GitHub which I have moved here as of 4/23/2022.
Abstract Data structure courses often introduce linked lists as a basic data structure as an alternative to arrays. They supposedly have the advantage of constant time insertion and deletion at any point in the list as long as you have access to a pointer near the node you are inserting or deleting.</description>
    </item>
    
    <item>
      <title>Ode to Binary Search</title>
      <link>/posts/ode-to-binary-search/</link>
      <pubDate>Mon, 05 Apr 2021 12:00:00 -0400</pubDate>
      
      <guid>/posts/ode-to-binary-search/</guid>
      <description>Note: This is a post originally written and posted to my GitHub which I have moved here as of 4/23/2022.
Introduction Given a sorted array, we can &amp;ldquo;binary search&amp;rdquo; through an array to find a certain element by comparing the middle element to our current element and then deciding either that we have found what we are looking for, that what we are looking for is in the left half of the array, or that what we are looking for is in the right half of the array.</description>
    </item>
    
    <item>
      <title>Chess Engine</title>
      <link>/projects/chess-engine/</link>
      <pubDate>Wed, 25 Nov 2020 12:00:00 -0400</pubDate>
      
      <guid>/projects/chess-engine/</guid>
      <description>I wrote my first chess engine, which you can find on my GitHub.
I will be writing an updated version soon, but as a placeholder, I will note that writing a chess engine teaches you a treasure trove of information, especially if you are aiming to write a fast one. I will give a small preview of things I have learned and plan to learn:
 I better learned to program in C++, specifically about minimizing my memory and performance footprints.</description>
    </item>
    
    <item>
      <title>Set Cover as Fast as Possible</title>
      <link>/projects/fast-minimum-set-cover/</link>
      <pubDate>Wed, 04 Nov 2020 12:00:00 -0400</pubDate>
      
      <guid>/projects/fast-minimum-set-cover/</guid>
      <description>Intro In the set cover problem, there exists a universe set U and a set S of subsets of U. The goal is to pick as few items of S as possible such that their union is equal to the set U.
This version of the problem, where we are trying to find the minimum number of elements of S such that their union is equal to S, is NP-hard. In practice, this means that this problem cannot be solved exactly nor verified efficiently.</description>
    </item>
    
  </channel>
</rss>
